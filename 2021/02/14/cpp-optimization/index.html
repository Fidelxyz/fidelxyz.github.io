<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="icon" type="image/ico" sizes="32x32" href="//cdn.jsdelivr.net/gh/Fidelxyz/fidelxyz.github.io@latest/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Fidel's Lab" href="https://fidel.js.org/rss.xml"><link rel="alternate" type="application/atom+xml" title="Fidel's Lab" href="https://fidel.js.org/atom.xml"><link rel="alternate" type="application/json" title="Fidel's Lab" href="https://fidel.js.org/feed.json"><link rel="stylesheet" href="//fonts.dogedoge.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/Fidelxyz/fidelxyz.github.io@latest/css/app.css"><meta name="keywords" content="技术"><link rel="canonical" href="https://fidel.js.org/2021/02/14/cpp-optimization/"><title>【转载】还能这样玩 —— 关于一些 OI 的黑 (sao) 科 (cao) 技 (zuo) 优化 | Fidel's Lab</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">【转载】还能这样玩 —— 关于一些 OI 的黑 (sao) 科 (cao) 技 (zuo) 优化</h1><div class="meta"><span class="item" title="Created: 2021-02-14 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2021-02-14T00:00:00+08:00">2021-02-14</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Fidel's Lab</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="//cdn.jsdelivr.net/gh/Fidelxyz/fidelxyz.github.io@latest/images/cover.webp"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="https://fidel.js.org/2021/02/14/cpp-optimization/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="//cdn.jsdelivr.net/gh/Fidelxyz/fidelxyz.github.io@latest/images/avatar.webp"><meta itemprop="name" content="玄云Fidel"><meta itemprop="description" content="不乱于心，不困于情。不畏将来，不念过往。, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fidel's Lab"></span><div class="body md" itemprop="articleBody"><blockquote><p>编者注：虽然标题中提到了 OI，但个人认为本文对追求极限的代码调优的价值远大于对 OI 的价值。</p></blockquote><div class="note info"><p>转载修改内容：</p><ol><li>修复了原文滥用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.89883em;vertical-align:-.2155em"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-.36em"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.68333em"><span style="top:-2.904999em"><span class="pstrut" style="height:2.7em"></span><span class="mord"><span class="mord textrm mtight sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-.15em"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-.1667em"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.46782999999999997em"><span style="top:-2.7845em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2155em"><span></span></span></span></span><span class="mspace" style="margin-right:-.125em"></span><span class="mord textrm">X</span></span></span></span></span></span> 问题。</li><li>对代码进行了格式化。</li><li>修改了原文汇编代码的错误注释。（汇编的注释符号是 <code>;</code> 而不是 <code>//</code> ！）</li><li>修改原文符号的不规范使用。</li><li>删除或修改了存在争议或错误的内容。</li></ol></div><span id="more"></span><hr><h1 id="免责声明"><a class="anchor" href="#免责声明">#</a> 免责声明</h1><blockquote><p>本文仅供参考，由读者引发的一切后果，任何责任由读者自行承担。后果包括但不限于：</p><ol><li>优化后程序变慢。</li><li>某些 OJ/OI 上导致的编译错误。</li><li>文章中的某些错误引起的争论。</li></ol></blockquote><h1 id="gcc-系列"><a class="anchor" href="#gcc-系列">#</a> GCC 系列</h1><p>关于 GCC 的黑科技想必大家也就知道这几句吧：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">GCC <span class="token function">optimize</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">GCC <span class="token function">optimize</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">GCC <span class="token function">optimize</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></span></span></pre></td></tr></table></figure><p>俗称 “吸氧”。</p><p>在这里小编就简单地讲一下 <code>-O1</code> , <code>-O2</code> , <code>-O3</code> , <code>-Os</code> （怎么还有个 <code>-Os</code> ）。</p><h2 id="o-系列"><a class="anchor" href="#o-系列">#</a> O 系列</h2><h3 id="-o1"><a class="anchor" href="#-o1">#</a> <code>-O1</code></h3><p>包含下列选项：</p><pre><code class="language-plain">-fauto-inc-dec
-fcprop-registers
-fdce
-fdefer-pop
-fdelayed-branch
-fdse
-fguess-branch-probability
-fif-conversion2
-fif-conversion
-finline-small-functions
-fipa-pure-const
-fipa-reference
-fmerge-constants -fsplit-wide-types
-ftree-builtin-call-dce
-ftree-ccp
-ftree-ch
-ftree-copyrename
-ftree-dce
-ftree-dominator-opts
-ftree-dse
-ftree-fre
-ftree-sra
-ftree-ter
-funit-at-a-time
-fomit-frame-pointer
</code></pre><h3 id="-o2"><a class="anchor" href="#-o2">#</a> <code>-O2</code></h3><p>除了加载 <code>-O1</code> 的选项外，还加载：</p><pre><code class="language-plain">-fthread-jumps
-falign-functions -falign-jumps
-falign-loops -falign-labels
-fcaller-saves
-fcr-Ossjumping
-fcse-follow-jumps -fcse-skip-blocks
-fdelete-null-pointer-checks
-fexpensive-optimizations
-fgcse -fgcse-lm
-findirect-inlining
-foptimize-sibling-calls
-fpeephole2
-fregmove
-freorder-blocks -freorder-functions
-frerun-cse-after-loop
-fsched-interblock -fsched-spec
-fschedule-insns -fschedule-insns2
-fstrict-aliasing -fstrict-overflow
-ftree-switch-conversion
-ftree-pre
-ftree-vrp
</code></pre><h3 id="-o3"><a class="anchor" href="#-o3">#</a> <code>-O3</code></h3><p>除了加载 <code>-O2</code> 外，还加载：</p><pre><code class="language-plain">-finline-functions
-funswitch-loops
-fpredictive-commoning
-fgcse-after-reload
-ftree-vectorize
</code></pre><h3 id="-os"><a class="anchor" href="#-os">#</a> <code>-Os</code></h3><p>在研究编译驱动的 makefile 的时候，发现 GCC 的命令行里面有一个 <code>-Os</code> 的优化选项。</p><p>遍查 GCC 文档，发现了 <code>-O0</code> , <code>-O1</code> , <code>-O2</code> , <code>-O3</code> ，就是没有发现 <code>-Os</code> 。</p><p>祭出 GOOGLE，搜了一下，终于发现这篇文章说明了 <code>-Os</code> 的作用：</p><p><span class="exturl" data-url="aHR0cDovL3d3dy5saW51eGpvdXJuYWwuY29tL2FydGljbGUvNzI2OQ==">http://www.linuxjournal.com/article/7269</span></p><p>原来 <code>-Os</code> 相当于 &quot;-O2.5&quot;。是使用了所有 <code>-O2</code> 的优化选项，但又不缩减代码尺寸的方法。<br>除了包含 <code>-O2</code> 的开关外， <code>-Os</code> 还会使得下列开关禁用。</p><pre><code class="language-plain">-falign-functions 
-falign-jumps 
-falign-loops
-falign-labels 
-freorder-blocks 
-freorder-blocks-and-partition
-fprefetch-loop-arrays 
-ftree-vect-loop-version
</code></pre><p>另外，对于多个 -O 选项的情形，最后一个加载的为有效。比如 <code>gcc -O1 -Os -O3 –o test test.c</code> ，有效的优化开关为 <code>-O3</code> 。</p><p>一般来说，用的最多的是 <code>-O3</code> 和 <code>-Os</code> ，如果遇到程序运行不正常的问题，请降低优化级别，如把 <code>-O3</code> 改为 <code>-O2</code> （情况很少见）。</p><h2 id="针对目标机器"><a class="anchor" href="#针对目标机器">#</a> 针对目标机器</h2><h3 id="-marchcpu-type"><a class="anchor" href="#-marchcpu-type">#</a> <code>-march=cpu-type</code></h3><p>为 cpu-type 所针对的机器开启需要的指令集。</p><p>cpu-type 可以为 pentium4、core2、athlon-4 等（具体参见文档），比如 <code>-march=core2</code> 时，则会开启 core2 所支持的 <code>MMX、SSE、SSE2、SSE3、SSSE3</code> 指令集。</p><p>另外还支持 <code>native</code> 类型，为编译器所在目前的 CPU 类型优化指令集，指定 <code>-march=native</code> 。</p><h3 id="-mfpmathunit"><a class="anchor" href="#-mfpmathunit">#</a> <code>-mfpmath=unit</code></h3><p>选择浮点运算单元。</p><p><code>unit</code> 可以为 <code>387</code> 和 <code>sse</code> 。</p><p><code>387</code> 为 x86 系列的默认值，使用标准的 387 浮点协处理器。</p><p><code>sse</code> 为 x64 的默认值，使用 <code>sse</code> 指令集。</p><p>一般你的程序如果有大量的浮点运算的话，在 P4 和 K8 以上级别的处理器上推荐开启 <code>-mfpmath=sse</code> 。</p><h3 id="加载指定指令集"><a class="anchor" href="#加载指定指令集">#</a> 加载指定指令集</h3><p>可以使用 <code>-msse2</code> 或 <code>-msse4.1</code> 加载指定的指令集。</p><h2 id="其他比较有效的选项"><a class="anchor" href="#其他比较有效的选项">#</a> 其他比较有效的选项</h2><h3 id="-ftracer"><a class="anchor" href="#-ftracer">#</a> <code>-ftracer</code></h3><p>执行尾部复制以扩大超级块的尺寸，它简化了函数控制流，从而允许其它的优化措施做的更好。单独使用没啥意义，和其他优化选项一起使用很有效。</p><h3 id="-ffast-math"><a class="anchor" href="#-ffast-math">#</a> <code>-ffast-math</code></h3><p>违反 IEEE/ANSI 标准以提高浮点数计算速度，是个危险的选项，仅在编译不需要严格遵守 IEEE 规范且浮点计算密集的程序考虑采用。不考虑精度时使用这个选项速度会加快。</p><h3 id="-fivopts"><a class="anchor" href="#-fivopts">#</a> <code>-fivopts</code></h3><p>在 trees 上执行归纳变量优化。</p><h3 id="-ftree-parallelize-loopsn"><a class="anchor" href="#-ftree-parallelize-loopsn">#</a> <code>-ftree-parallelize-loops=n</code></h3><p>使循环并行化。只当循环无数据依赖时使用，在多核 CPU 上时使用才会有利。</p><h3 id="-ftree-loop-linear"><a class="anchor" href="#-ftree-loop-linear">#</a> <code>-ftree-loop-linear</code></h3><p>在 trees 上进行线型循环转换。它能够改进缓冲性能并且允许进行更进一步的循环优化。</p><h3 id="-fforce-addr"><a class="anchor" href="#-fforce-addr">#</a> <code>-fforce-addr</code></h3><p>必须将地址复制到寄存器中才能对他们进行运算。由于所需地址通常在前面已经加载到寄存器中了，所以这个选项可以改进代码。</p><h3 id="-floop-interchange"><a class="anchor" href="#-floop-interchange">#</a> <code>-floop-interchange</code></h3><p>交换循环变量。</p><p>例如：</p><pre><code class="language-plain">DO J = 1, M
  DO I = 1, N
    A(J, I) = A(J, I) * C
  ENDDO
ENDDO
</code></pre><p>会改变为：</p><pre><code class="language-plain">DO I = 1, N
  DO J = 1, M
    A(J, I) = A(J, I) * C
  ENDDO
ENDDO
</code></pre><p>改变后，如果 N 比缓冲区大的话，会更有效率。这是因为 Fortran 里数组是以列主元为排列方式的。当然这个选项并不仅仅用于 Fortran，gcc 家族的编译器都有效。</p><h3 id="-fvisibilityhidden"><a class="anchor" href="#-fvisibilityhidden">#</a> <code>-fvisibility=hidden</code></h3><p>设置默认的 ELF 镜像中符号的可见性为隐藏。使用这个特性可以非常充分的提高连接和加载共享库的性能，生成更加优化的代码，提供近乎完美的 API 输出和防止符号碰撞。我们强烈建议你在编译任何共享库（Dll）的时候使用该选项。</p><pre><code class="language-plain">-fvisibility-inlines-hidden
</code></pre><p>默认隐藏所有内联函数，从而减小导出符号表的大小，既能缩减文件的大小，还能提高运行性能，强烈建议你在编译任何共享库的时候使用该选项。</p><h3 id="-minline-all-stringops"><a class="anchor" href="#-minline-all-stringops">#</a> <code>-minline-all-stringops</code></h3><p>默认时 GCC 只将确定目的地会被对齐在至少 4 字节边界的字符串操作内联进程序代码。该选项启用更多的内联并且增加二进制文件的体积，但是可以提升依赖于高速 <code>memcpy</code> , <code>strlen</code> , <code>memset</code> 操作的程序的性能。</p><h3 id="-m64"><a class="anchor" href="#-m64">#</a> <code>-m64</code></h3><p>生成专门运行于 64 位环境的代码，不能运行于 32 位环境，仅用于 x86_64 [含 EMT64] 环境。</p><h3 id="-fprefetch-loop-arrays"><a class="anchor" href="#-fprefetch-loop-arrays">#</a> <code>-fprefetch-loop-arrays</code></h3><p>生成数组预读取指令，对于使用巨大数组的程序可以加快代码执行速度，适合数据库相关的大型软件等。具体效果如何取决于代码。不能和 <code>-Os</code> 一起使用。</p><h3 id="-pipe"><a class="anchor" href="#-pipe">#</a> <code>-pipe</code></h3><p>在编译过程的不同阶段之间使用管道而非临时文件进行通信，可以加快编译速度。建议使用。</p><h2 id="推荐选项开关"><a class="anchor" href="#推荐选项开关">#</a> 推荐选项开关</h2><p>综上，比较<strong>安全</strong>的<strong>开关</strong>为</p><pre><code class="language-plain">-pipe
-O3 (-Os)
-march=native
-mfpmath=sse
-msse2
-ftracer
-fivopts
-ftree-loop-linear
-fforce-addr
</code></pre><p>如果不需要多高的精度，比如 GUI 框架之类，加入：</p><pre><code class="language-plain">-ffast-math
</code></pre><p>如果是编译的是共享库（ <code>.dll</code> , <code>.a</code> ）加入</p><pre><code class="language-plain">-fvisibility=hidden
-fvisibility-inlines-hidden
</code></pre><p><strong>注意某些比赛不能使用 <code>-O1</code> , <code>-O2</code> , <code>-O3</code> , <code>-Os</code> .</strong></p><h1 id="底层优化坑"><a class="anchor" href="#底层优化坑">#</a> 底层优化（坑）</h1><h2 id="io-优化"><a class="anchor" href="#io-优化">#</a> I/O 优化</h2><p>I/O 优化是卡常中最常用的技巧，当数据较大的时候，读入输出占用了很多时间。</p><h3 id="读入优化"><a class="anchor" href="#读入优化">#</a> 读入优化</h3><p>流输入方式很方便，不需要记忆占位符，但每次读入时，它都要检测是否和 <code>stdin</code> 的同步（是否被 <code>freopen</code> 改变 / 是否被 <code>scanf</code> 读取），因此它是可以和 <code>scanf</code> 混用的。但也导致了它每次都要从数据开始位置跳转到当前读入的位置，浪费了大量时间，可以用 <code>std::ios::sync_with_stdio(false);</code> 关闭两者的同步以加快速度，这样做之后会比 <code>scanf</code> 还快！但必须注意，调用后不能再用 <code>freopen</code> ，但是还可以用 <code>fstream</code> 。</p><p>当然，更好的方法是用 <code>getchar</code> 自己写读入函数。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>sum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> tf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">&lt;</span> <span class="token string">'0'</span> <span class="token operator">||</span> ch <span class="token operator">></span> <span class="token string">'9'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>ch <span class="token operator">!=</span> <span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    tf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>ch <span class="token operator">>=</span> <span class="token string">'0'</span> <span class="token operator">&amp;&amp;</span> ch <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">)</span> sum <span class="token operator">=</span> sum <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ch <span class="token operator">-</span> <span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">(</span>tf<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>sum <span class="token operator">=</span> <span class="token operator">-</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><div class="note primary"><p>编者注：</p><p>补充一份我自己使用的快读：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">while</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token string">'0'</span> <span class="token operator">||</span> c <span class="token operator">></span> <span class="token string">'9'</span><span class="token punctuation">)</span> f <span class="token operator">|=</span> c <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">while</span> <span class="token punctuation">(</span>c <span class="token operator">>=</span> <span class="token string">'0'</span> <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">)</span> x <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> c <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">return</span> f <span class="token operator">?</span> <span class="token operator">-</span>x <span class="token operator">:</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>优势：更短，且不会因为代码格式化而展开。</p></div><p>这样效率有了很大的提升，而且可以和 <code>scanf</code> 混用（字符串等），第 7 行和第 10 行的代码后面会说。</p><p>我们知道， <code>getchar</code> 是逐字符读取的，在 <code>stdio.h</code> 中，有一个 <code>fread</code> 函数，能整段读取，比 <code>getchar</code> 还快，并且支持 <code>freopen</code> （完美兼容）和 <code>fopen</code> （需要把下面的所有 <code>stdin</code> 改成你的文件指针）。</p><p>函数原型： <code>size_t fread(void *buffer, size_t size, size_t count, FILE *stream);</code></p><p>作用：从 <code>stream</code> 中读取 <code>count</code> 个大小为 <code>size</code> 个字节的数据，放到数组 <code>buffer</code> 中，返回成功了多少个大小为 size 个字节的数据。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">inline</span> <span class="token keyword">char</span> <span class="token function">nc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1000000</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> buf<span class="token punctuation">,</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> buf<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span> p1 <span class="token operator">==</span> p2 <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>p2 <span class="token operator">=</span> <span class="token punctuation">(</span>p1 <span class="token operator">=</span> buf<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fread</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1000000</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">EOF</span> <span class="token operator">:</span> <span class="token operator">*</span>p1<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">//#define nc getchar</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>sum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token function">nc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">int</span> tf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">&lt;</span> <span class="token string">'0'</span> <span class="token operator">||</span> ch <span class="token operator">></span> <span class="token string">'9'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>ch <span class="token operator">!=</span> <span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> ch <span class="token operator">=</span> <span class="token function">nc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    tf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token function">nc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>ch <span class="token operator">>=</span> <span class="token string">'0'</span> <span class="token operator">&amp;&amp;</span> ch <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">)</span> sum <span class="token operator">=</span> sum <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ch <span class="token operator">-</span> <span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ch <span class="token operator">=</span> <span class="token function">nc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">(</span>tf<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>sum <span class="token operator">=</span> <span class="token operator">-</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>但要注意，由于这种方法是整段读取的，这也造就了它两个巨大的缺陷：</p><ol><li><strong>不能用键盘输入。数据还没输入，程序怎么整段读取。如果你需要在电脑上用键盘输入调试，请把第 6 行的注释取消。</strong></li><li><strong>不能和 <code>scanf</code> ， <code>getchar</code> 等其他读入方法混合使用。因为 fread 是整段读取的，也就是说所有数据都被读取了，其他函数根本读取不到任何东西（只能从你的读取大小后面开始读），因此，所有类型的变量读入都必须自己写，上面的 <code>read</code> 函数只支持 <code>int</code> 类型。</strong></li></ol><p>下面是测试，摘自 LibreOJ，单位为毫秒（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">n=3 \times 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">3</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>）。</p><table><thead><tr><th>读入方法</th><th>编译器</th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mn>1</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0,2^1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0,2^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mn>15</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0,2^{15})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mn>31</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0,2^{31})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mn>63</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0,2^{63})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></th></tr></thead><tbody><tr><td><code>fread</code></td><td>G++ 5.4.0 ( <code>-O2</code> )</td><td>13</td><td>13</td><td>39</td><td>70</td><td>111</td></tr><tr><td><code>getchar</code></td><td>G++ 5.4.0 ( <code>-O2</code> )</td><td>58</td><td>73</td><td>137</td><td>243</td><td>423</td></tr><tr><td><code>cin</code> （关闭同步）</td><td>G++ 5.4.0 ( <code>-O2</code> )</td><td>161</td><td>147</td><td>205</td><td>270</td><td>394</td></tr><tr><td><code>scanf</code></td><td>G++ 5.4.0 ( <code>-O2</code> )</td><td>182</td><td>175</td><td>256</td><td>368</td><td>574</td></tr><tr><td><code>cin</code></td><td>G++ 5.4.0 ( <code>-O2</code> )</td><td>442</td><td>429</td><td>706</td><td>1039</td><td>1683</td></tr></tbody></table><p>没错，你没有看错， <code>fread</code> 以压倒性的优势碾压了其他所有方法，而关闭同步的 <code>cin</code> 比 <code>scanf</code> 快，并且读 <code>long long</code> 的时候比 <code>getchar</code> 还要快。</p><hr><p><strong>下面的内容某些 OI 比赛不支持。慎用！</strong></p><p>其实还可以更快， <code>Linux</code> 下 <code>sys/mman.h</code> 中存在函数 <code>mmap</code> ， <code>scanf</code> 底层实现时调用的就是 <code>mmap</code> 函数，其作用是把文件映射进内存，这里仅仅给出代码，有兴趣的同学可以自行查阅有关资料。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">namespace</span> Inputs <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">io</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">mmap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">26</span><span class="token punctuation">,</span> PROT_READ<span class="token punctuation">,</span> MAP_PRIVATE<span class="token punctuation">,</span> <span class="token function">fileno</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">scan</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>s <span class="token operator">&lt;</span> <span class="token number">48</span><span class="token punctuation">)</span> <span class="token operator">++</span>s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>s <span class="token operator">></span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">*</span>u<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>s<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token operator">*</span>u <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">int</span> <span class="token function">scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">int</span> Hibiki <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>s <span class="token operator">&lt;</span> <span class="token number">48</span><span class="token punctuation">)</span> v <span class="token operator">=</span> <span class="token operator">*</span>s<span class="token operator">++</span> <span class="token operator">^</span> <span class="token number">45</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>s <span class="token operator">></span> <span class="token number">32</span><span class="token punctuation">)</span> Hibiki <span class="token operator">=</span> Hibiki <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token operator">*</span>s<span class="token operator">++</span> <span class="token operator">-</span> <span class="token number">48</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> Hibiki <span class="token operator">*</span> v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><hr><p>有人喜欢用 <code>isdigit</code> 宏，但这个宏在本机测试上的确更慢了，这个宏的效率还有待研究。</p><h3 id="输出优化"><a class="anchor" href="#输出优化">#</a> 输出优化</h3><p>输出优化并不是十分常用，因为很少有题目要求大量输出，这里仍然给出代码。（第 4 行以后再说）</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token function">putchar</span><span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">putchar</span><span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x <span class="token operator">=</span> <span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">int</span> tp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        a<span class="token punctuation">[</span><span class="token operator">++</span>tp<span class="token punctuation">]</span> <span class="token operator">=</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        x <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> tp<span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token function">putchar</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果你按照上面的代码打，那只能说明你的想象力不够， <code>fwrite</code> 扑进 <code>fread</code> 的怀里失声痛哭。 <code>fwrite</code> 的优势被你完美地抛弃了，取而代之的是逐字符输出的 <code>putchar</code> 。</p><p>函数原形：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>size_t <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> size_t count<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>作用：把 <code>buffer</code> 中的数据拆成大小为 <code>size</code> 个字节的数据，输出前 <code>count</code> 个到 <code>stream</code> 中，实际成功写入的大小为 <code>size</code> 的数据块数目。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> Ostream <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> BUF <span class="token operator">=</span> <span class="token number">50000000</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUF<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>h <span class="token operator">=</span> buf<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">char</span> ch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    h <span class="token operator">==</span> buf <span class="token operator">+</span> BUF <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token function">fwrite</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> BUF<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">,</span> h <span class="token operator">=</span> buf<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token operator">*</span>h<span class="token operator">++</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">putint</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">char</span> _buf<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">sprintf</span><span class="token punctuation">(</span>_buf<span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//(*)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s <span class="token operator">=</span> _buf<span class="token punctuation">;</span> <span class="token operator">*</span>s<span class="token punctuation">;</span> s<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">fwrite</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> h <span class="token operator">-</span> buf<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>有人也许会说，上面的代码的 (*) 处还可以优化，但这个优化的意义并不大，当然，也可以优化。</p><p>下面是测试：</p><p>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">n = 5 \times 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">5</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span> , rand)</p><p>Clock Rate: 3.70 GHz</p><p>RAM: 4 GB</p><table><thead><tr><th>方法</th><th>编译器</th><th>时间 (ms)</th></tr></thead><tbody><tr><td><code>printf</code></td><td>G++ 5.4.0</td><td>21278</td></tr><tr><td><code>sprintf</code> + <code>puts</code></td><td>G++ 5.4.0</td><td>21426</td></tr><tr><td>纯 <code>sprintf</code> 不输出</td><td>G++ 5.4.0</td><td>540</td></tr><tr><td><code>fprintf(stdin)</code></td><td>G++ 5.4.0</td><td>26037</td></tr><tr><td><code>putchar</code></td><td>G++ 5.4.0</td><td>98556</td></tr><tr><td><code>sprintf</code> + <code>fwrite</code></td><td>G++ 5.4.0</td><td>607</td></tr></tbody></table><p>由上表得， <code>sprintf</code> 的复杂度并不高， <code>fwrite</code> 也没有给 <code>fread</code> 丢脸。而 <code>fprintf</code> 的表现却让人大跌眼镜。 <code>getchar</code> 的结果很可能具有偶然性，反正上面的数据是在小编的机器上用同一组随机数测的。</p><h2 id="位运算"><a class="anchor" href="#位运算">#</a> 位运算</h2><p>在很多时候，我们会听到很多有关位运算的追捧，像 “位运算的常数很小，比加减法还要快”。这是真的吗？</p><h3 id="左移和右移的天上地下"><a class="anchor" href="#左移和右移的天上地下">#</a> 左移和右移的天上地下</h3><p>下面有两段代码：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    x <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    x <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>它们理论上是等价的，但 g++ 翻译成汇编后呢？</p><p>两段代码的汇编代码是一样的！下面是 <code>x&lt;&lt;=1</code> 和 <code>x*=2</code> 被翻译后的代码。</p><pre><code class="language-assembly">addl    %eax, %eax
</code></pre><p>它等价于 <code>a=a+a</code> 。是不是被打脸了，响不响，痛不痛，红不红，痒不痒…… 好吧，从上面的例子可以看出，某些时候自作聪明的优化并没有任何用。</p><p>那乘以 4 呢？翻译后的代码还是一样的：</p><pre><code class="language-assembly">sall    $2, %eax
</code></pre><p>上面的代码等价于 <code>x&lt;&lt;=2</code> 。现在死心了吧。</p><p>或许你还执着于 <code>x*=10</code> 。这次翻译后的汇编代码终于不一样了，下面是 <code>x*=10</code> 的汇编代码（ <code>-O2</code> 优化）：</p><pre><code class="language-assembly">leal    (%eax,%eax,4), %eax
addl    %eax, %eax
</code></pre><p>只有两条指令：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>x<span class="token operator">=</span>x<span class="token operator">+</span>x<span class="token operator">*</span><span class="token number">4</span> <span class="token comment">// 别看是加法和乘法，却是一条指令完成</span></pre></td></tr><tr><td data-num="2"></td><td><pre>x<span class="token operator">=</span>x<span class="token operator">+</span>x   <span class="token comment">// 加法还不容易吗</span></pre></td></tr></table></figure><p>那些喜欢用 <code>x=(x&lt;&lt;3)+(x&lt;&lt;1)</code> 的人请自重。</p><p>那是不是说位运算一无所用呢？并不是，在除法方面有不少用处。</p><p>右移的汇编代码：</p><pre><code class="language-assembly">  movl    _x, %eax
  sarl    %eax
  movl    %eax, _x
  movl    _x, %eax
</code></pre><p>除以 2 的代码：</p><pre><code class="language-assembly">  movl    _x, %eax
  movl    %eax, %edx  ;(del)
  shrl    $31, %edx   ;(del)
  addl    %edx, %eax  ;(del)
  sarl    %eax
  movl    %eax, _x
  movl    _x, %eax
</code></pre><p>整整多了三行。</p><p>但这种情况仅限于有符号的整数，因为有符号的整数的右移和除法不是同一个东西，编译器还需要修正一下。<br>如果用的是 <code>unsigned</code> 类型，那汇编代码又一样了。</p><h3 id="mod-和-and-的战争"><a class="anchor" href="#mod-和-and-的战争">#</a> Mod 和 And 的战争</h3><p>下面是 <code>x%2</code> 的代码（ <code>-O2</code> ）：</p><pre><code class="language-assembly">  movl    _x, %eax
  movl    $LC0, (%esp)
  movl    %eax, %edx   ;(del)
  shrl    $31, %edx    ;(del)
  addl    %edx, %eax   ;(del)
  andl    $1, %eax
  subl    %edx, %eax   ;(del)
  movl    %eax, 4(%esp)
  movl    %eax, _x
</code></pre><p>那 <code>x&amp;1</code> 呢？少了 4 条语句（ <code>-O2</code> ）：</p><pre><code class="language-assembly">  movl    _x, %eax
  movl    $LC0, (%esp)
  andl    $1, %eax
  movl    %eax, 4(%esp)
  movl    %eax, _x
</code></pre><h3 id="xor-和-temp-的故事"><a class="anchor" href="#xor-和-temp-的故事">#</a> Xor 和 temp 的故事</h3><p>相信大家在学交换两个变量的值的时候一定会先学习所谓的 “三变量交换法”，然后就被异或取代了。</p><p>下面是异或（ <code>a^=b^=a^=b</code> ）的汇编：</p><pre><code class="language-assembly">  movl    _b, %edx
  movl    _a, %eax
  xorl    %edx, %eax
  xorl    %eax, %edx
  xorl    %edx, %eax
  movl    %eax, _a
  xorl    %eax, %eax
  movl    %edx, _b
</code></pre><p>有 <code>movl</code> 指令和 <code>xorl</code> 指令各 4 条。<br>那三变量交换法（ <code>int t=a; a=b, b=t;</code> ）呢？</p><pre><code class="language-assembly">  movl    _a, %eax
  movl    _b, %edx
  movl    %eax, _b
  xorl    %eax, %eax
  movl    %edx, _a
</code></pre><p>从此，有 temp 再没有异或。</p><h3 id="神奇的位运算技巧"><a class="anchor" href="#神奇的位运算技巧">#</a> 神奇的 “位运算技巧”</h3><p>网上有很多奇奇怪怪的方法，例如取绝对值 <code>(n^(n&gt;&gt;31))-(n&gt;&gt;31)</code> ，取两个数的最大值 <code>b&amp;((a-b)&gt;&gt;31)|a&amp;(~(a-b)&gt;&gt;31)</code> ，取两个数的最小值 <code>a&amp;((a-b)&gt;&gt;31)|b&amp;(~(a-b)&gt;&gt;31)</code> 。</p><p>喜欢用上面代码的人难道没有自己亲自数一数上面有多少条位运算的指令吗？</p><p>但凡事没有绝对，还是有一些优秀的例子的：</p><p>取<strong>二进制下</strong>最后一个 <code>1</code> 和后面的 <code>0</code> ：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">lowbit</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span>x<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>判断一个数是不是 2 的幂：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>n<span class="token operator">></span><span class="token number">0</span><span class="token operator">?</span><span class="token punctuation">(</span>n<span class="token operator">&amp;</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">:</span><span class="token boolean">false</span></pre></td></tr></table></figure><h3 id="xor-和网络流的故事"><a class="anchor" href="#xor-和网络流的故事">#</a> Xor 和网络流的故事</h3><p>还记得网络流的反向弧？通常某些人喜欢在结构体中新建一个变量来表示这条边的反向弧编号。但这样不免有些浪费，因为在插入新边的时候，我们一般会把两条互为反向弧的边相邻插入，有一个有趣的性质可以完美地解决这个问题：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>x<span class="token operator">+</span><span class="token number">1</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>x</pre></td></tr></table></figure><p>也就是说，我们可以用异或节省下一个空间。</p><p>那在汇编中呢？异或本来就是逻辑运算，一条指令 <code>xorl $1, _x</code> 搞定，但如果用另一个变量呢？编译器需要对变量进行初始化，还多了一条指令。</p><h2 id="条件语句"><a class="anchor" href="#条件语句">#</a> 条件语句</h2><p>相信条件语句会在程序中经常出现，而且也是不可避免的，谁知道，这么死板的事情还可以再优化。</p><h3 id="if-和-的故事"><a class="anchor" href="#if-和-的故事">#</a> <code>if</code> 和 <code>?:</code> 的故事</h3><div class="note warning"><p>编者注：<strong>原文内容存在错误，已删除。</strong></p></div><blockquote><p><strong>if-else 与 <code>?:</code> 运算符本质上相同，大多数情况下所产生的汇编代码完全相同。</strong></p><blockquote><p>对于下面的两段代码：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">else</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>x <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>网上有人说，三目运算符比 <code>if</code> 语句快，所以第二段代码就比第一段代码快。</p><p>实际上汇编代码是一模一样的，所以运行时间也是一样的。</p><p><strong>摘自：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvemhhb2ppbnhpL29wdGltaXpl">浅谈底层常数优化及编译器优化 - zhaojinxi 的博客 - 洛谷博客</span></strong></p></blockquote><p><strong><code>?:</code> 运算符并不会消除分支预测。</strong></p><p>分支预测的原理，是在 if 括号内部的判断语句未执行完成时，<strong>在另一线程中</strong>预测一条分支执行接下来的语句。当判断语句执行完毕时，若执行结果与预测相同，则继续执行该分支语句；若执行结果与预测不同，则重新执行另一分支语句。<strong>分支预测可以充分发挥 CPU 的多线程性能</strong>，避免多余的等待。</p><p>分支预测的效率取决于 CPU 的设计。<strong>在大部分情况下，分支预测能加快运算速度</strong>，除非分支预测的准确度极低。毕竟 CPU 的设计者也不是傻子。</p><p>分享一篇不错的关于分支预测的文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzMwMDk3NTg2NC9hbnN3ZXIvMTgwNTU1ODAyMA==">为什么很多程序员不用 switch，而是大量的 if...else if ...？ - 是 Yes 呀的回答 - 知乎</span></p></blockquote><hr><p>下面的内容某些 OI 比赛不支持。<strong>慎用</strong>！</p><p>gcc 存在内置函数： <code>__builtin_expect(!!(x), tf)</code></p><p>当 <code>tf</code> 为 <code>true</code> 时表示 <code>x</code> 非常可能为 <code>true</code> ，反之同理。</p><p>用法： <code>if(__builtin_expect(!!(x), tf))</code></p><blockquote><p>编者附：</p><p>而 <code>GCC</code> 提供了一个内建函数 <code>__builtin_expect</code> ，通过分支预测提高效率，将接下来运行的可能性较大的代码放在靠前的位置，减少指令跳转，这样保证了空间局部性，可以减少 cache miss。但经过测试后发现， <code>__builtin_expect</code> 仅在开启 <code>-O2</code> 优化下有效。</p><p>例如下面的代码：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>       <span class="token function">srand</span><span class="token punctuation">(</span><span class="token number">2333</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>       <span class="token keyword">int</span> cnt1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>           <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>           <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>               <span class="token operator">++</span>cnt1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>           <span class="token keyword">else</span></pre></td></tr><tr><td data-num="11"></td><td><pre>               <span class="token operator">++</span>cnt2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>       <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span> cnt1<span class="token punctuation">,</span> cnt2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token number">2333</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">int</span> cnt1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>           <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span><span class="token punctuation">(</span>t <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>               <span class="token operator">++</span>cnt1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>           <span class="token keyword">else</span></pre></td></tr><tr><td data-num="11"></td><td><pre>               <span class="token operator">++</span>cnt2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>       <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span> cnt1<span class="token punctuation">,</span> cnt2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>使用 <code>__builtin_expect (t &lt; 10, false)</code> 后，编译器把 <code>else</code> 后的语句放到了紧跟着前面的语句的位置，而当 <code>t &lt; 10</code> 为 <code>true</code> 时才进行跳转。</p><p><strong>摘自：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvemhhb2ppbnhpL29wdGltaXpl">浅谈底层常数优化及编译器优化 - zhaojinxi 的博客 - 洛谷博客</span></strong></p></blockquote><hr><h3 id="switch-和-if-else-的故事"><a class="anchor" href="#switch-和-if-else-的故事">#</a> <code>switch</code> 和 <code>if-else</code> 的故事</h3><p>下面有两段代码，你觉得那段更快呢？</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    x<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    x <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    x <span class="token operator">/=</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    x <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">switch</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        x<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        x <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        x <span class="token operator">/=</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        x <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>显然地，下面的代码更快，因为上面的代码需要逐条判断，而下面的代码直接跳转。</p><p>那是不是所有 <code>switch</code> 都比 <code>if</code> 快呢？凡事没有绝对，当 <code>switch</code> 遇到 <code>default</code> 的时候，整个程序的效率就会大打折扣，因为它又回到了 <code>if</code> 的无脑判断模式。再比如，当 <code>if</code> 用来判断区间的时候就比 <code>switch</code> 快， <code>if</code> 只需要做三次逻辑运算（两条判断，一条逻辑与），而 <code>switch</code> 呢？我就呵呵一笑。</p><h3 id="短路的故事"><a class="anchor" href="#短路的故事">#</a> 短路的故事</h3><p>此短路非彼短路，它指的是一种运算符的特性。</p><p>我们常用的逻辑运算符，例如 <code>&amp;&amp;</code> 和 <code>||</code> 都是短路运算符。什么意思呢？比如在运算 <code>A &amp;&amp; B</code> 时，如果发现 A 已经为 <code>false</code> ，就不会再计算 B。</p><p>现在你能解释第一章中留下的问题了吗？</p><p><code>(tf)&amp;&amp;(sum=-sum);</code> 当 <code>tf</code> 为 <code>true</code> 的时候，会执行后面的 <code>sum=-sum</code> ，如果 <code>tf</code> 为 <code>false</code> ，则不会执行后面的 <code>sum=-sum</code> 。</p><p>等价于如下语句：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>tf<span class="token punctuation">)</span> sum <span class="token operator">=</span> <span class="token operator">-</span>sum<span class="token punctuation">;</span></pre></td></tr></table></figure><hr><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>tf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>当 <code>ch='-'</code> 时，会执行后面的 <code>ch=getchar()</code> ，因为 <code>getchar</code> 一般不会等于 <code>0</code> （如果不放心可以写成 <code>tf=((ch=='-')&amp;&amp;((ch=getchar()),true))</code> ），因此 <code>tf</code> 的结果等于 <code>true</code> 。</p><p>当 <code>ch!='-'</code> 时，不会执行后面的 <code>ch=getchar()</code> ， <code>tf</code> 的值为 <code>false</code> 。</p><p>等价于如下语句：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    tf <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>总结一下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> B<span class="token punctuation">;</span> ⇔ <span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> B<span class="token punctuation">;</span> <span class="token keyword">else</span> C<span class="token punctuation">;</span> ⇔ A<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">||</span>C</pre></td></tr></table></figure><p>为什么？详情参见下一小节。</p><p>如果短路运算符只能改写 <code>if</code> 语句，那这里就不会浪费这么多篇幅来介绍这个东西。事实上，这个东西比我们想象得有用得多。看下面两段代码：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">double</span> t <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">/</span> RAND_MAX <span class="token operator">&lt;</span> <span class="token number">0.2</span> <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">double</span> t <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> t <span class="token operator">/</span> RAND_MAX <span class="token operator">&lt;</span> <span class="token number">0.2</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>你认为哪一份代码会更快？</p><p>好像没什么区别对吧。但对于 CPU 来说很有区别。第一段代码中的 <code>t / RAND_MAX &lt; 0.2</code> 为 <code>true</code> 的概率约为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">20\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80556em;vertical-align:-.05556em"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">%</span></span></span></span>，但 <code>t!=0</code> 为 <code>true</code> 的概率约为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mi>R</mi><mi>A</mi><mi>N</mi><mi>D</mi><mi mathvariant="normal">_</mi><mi>M</mi><mi>A</mi><mi>X</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{RAND\_MAX}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.407108em;vertical-align:-.5619999999999999em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.845108em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.00773em">R</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:.10903em">N</span><span class="mord mathnormal mtight" style="margin-right:.02778em">D</span><span class="mord mtight" style="margin-right:.02778em">_</span><span class="mord mathnormal mtight" style="margin-right:.10903em">M</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:.07847em">X</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.5619999999999999em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，明显小于 20%。<br>因此，如果把计算一个不含逻辑运算符布尔表达式的计算次数设为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 次，设计算了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.07847em">X</span></span></span></span> 次，则对于第一段代码，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.07847em">X</span></span></span></span> 的数学期望为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>65</mn></mrow><annotation encoding="application/x-tex">65</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">6</span><span class="mord">5</span></span></span></span>，但对于第二段代码，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.07847em">X</span></span></span></span> 的数学期望为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>2</mn><mo>×</mo><mo stretchy="false">(</mo><mi>R</mi><mi>A</mi><mi>N</mi><mi>D</mi><mi mathvariant="normal">_</mi><mi>M</mi><mi>A</mi><mi>X</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mrow><mi>R</mi><mi>A</mi><mi>N</mi><mi>D</mi><mi mathvariant="normal">_</mi><mi>M</mi><mi>A</mi><mi>X</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{2\times (RAND\_MAX-1)}{RAND\_MAX}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6139999999999999em;vertical-align:-.5619999999999999em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0519999999999998em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.00773em">R</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:.10903em">N</span><span class="mord mathnormal mtight" style="margin-right:.02778em">D</span><span class="mord mtight" style="margin-right:.02778em">_</span><span class="mord mathnormal mtight" style="margin-right:.10903em">M</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:.07847em">X</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.527em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">×</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:.00773em">R</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:.10903em">N</span><span class="mord mathnormal mtight" style="margin-right:.02778em">D</span><span class="mord mtight" style="margin-right:.02778em">_</span><span class="mord mathnormal mtight" style="margin-right:.10903em">M</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:.07847em">X</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.5619999999999999em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，远远大于第一段代码。</p><p>总结一下，</p><ul><li>遇到 <code>A&amp;&amp;B</code> 时，优先把可能为 <code>false</code> 的表达式放在前面。</li><li>遇到 <code>A||B</code> 时，优先把可能为 <code>true</code> 的表达式放在前面。</li></ul><h3 id="布尔表达式和逗号运算符的故事"><a class="anchor" href="#布尔表达式和逗号运算符的故事">#</a> 布尔表达式和逗号运算符的故事</h3><p>为什么要专门设置这么一小节呢？<br>因为很多人喜欢用 <code>if(x==true)</code> ，直接用 <code>if(x)</code> 就好了。还有 <code>x==false</code> 和 <code>!x</code> ，它们也是等价的。</p><p>现在，请另一位大佬隆重登场：逗号运算符。</p><p>若干条语句可以通过逗号运算符合并成一条语句。<br>例如 <code>t=a;a=b;b=t;</code> 可以写成 <code>t=a,a=b,b=t;</code> 有什么用吗？它的返回值。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>猜一猜，上面的语句执行完后 <code>x​</code> 的值是多少？</p><p>答案是 9。没错，逗号运算符的返回值就是最后一个的值。</p><p>现在可以解释上一小节留下总结了吧。</p><p><code>A&amp;&amp;(B,1)||C</code> ：当 <code>A</code> 为 <code>true</code> 时会执行 <code>(B,1)</code> ，返回值为 <code>true</code> ，因此 <code>A&amp;&amp;(B,1)</code> 的返回值为 <code>true</code> ，因此不会执行 <code>C</code> ，当 <code>A</code> 为 <code>false</code> 时，不会执行 <code>(B,1)</code> ，且 <code>A&amp;&amp;(B,1)</code> 的值为 <code>false</code> ，因此会执行 <code>C</code> 。</p><h2 id="standard-template-library"><a class="anchor" href="#standard-template-library">#</a> Standard Template Library</h2><p>如果能熟练使用 STL，则可以大大减小代码复杂度，提高对于部分人的可读性（前提是那个人也会 STL）。但在很多 OI 比赛中，STL 会成为性能瓶颈（不仅仅是常数瓶颈），而且要明白：对于 STL 来说， <code>-O2</code> 的开与否带来的不仅仅是几毫秒的差，而是一种蜕变！</p><h3 id="容器"><a class="anchor" href="#容器">#</a> 容器</h3><h4 id="完全连续容器"><a class="anchor" href="#完全连续容器">#</a> 完全连续容器</h4><p>在 STL 中，唯一的真正意义上的完全连续容器应该只有 <code>vector</code> 和 <code>bitset</code> 了，其中， <code>vector</code> 中的所有元素都是连续的，但它是怎么做到的？在某些编译器中，它实现内存分配的方法是当前的容量不足时，申请一块当前容量 2 倍的新内存空间，然后将所有的老元素全部拷贝到新内存中，添加大量元素的时候的花费的惊人的大。和 <code>allocator</code> 的时间复杂度一样。</p><p>函数原型： <code>extern void *realloc(void *memory, unsigned int newsize);</code></p><p>作用：把 <code>memory</code> 开头的指针所占用的空间修改成 <code>newsize</code> 个字节大小。</p><p>内部是怎么实现的？在内存中寻找一片足够大的连续空间，然后把原来地方的数据拷到新空间中。</p><p>听着就觉慢，因此在 <code>vector</code> 需要存储大量数据的时候，尽量不要用 <code>push_back</code> ，直接用 <code>resize(size_type size)</code> 函数改变大小，或者先用 <code>reserve(size_type size)</code> 函数预留空间，然后再用 <code>push_back</code> 方法，这样能尽可能地降低其弊端。</p><p>但由于其是完全连续容器，因此在查找的时候效率和普通数组没有太大区别。</p><p>邻接表有两种实用的方法，一种是前向星（有人也叫向前星，这里以百度百科为准），另一种就是用 <code>vector</code> 。</p><p>尽管 <code>vector</code> 修改大小的时候会很浪费时间，但要知道， <code>vector</code> 可是一个完全连续容器，相比前向星好了不知道多少（从一个数组里跳来跳去）。</p><p>在某些需要频繁访问边（例如网络流和最短路），遇到很稠密的图的时候， <code>vector</code> 完全连续的作用就被发挥到了最大，而动态开辟空间的消耗也已被降到了最低最低，尤其是在开了 <code>-O2</code> 优化的时候。</p><p>下面分别是 <code>vector</code> 和前向星跑网络流（ISap）的用时。（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>50</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">m=50n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mord">0</span><span class="mord mathnormal">n</span></span></span></span>）</p><table><thead><tr><th>存图方法</th><th>编译器</th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">n=10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">n=10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">n=5 \times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">5</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></th></tr></thead><tbody><tr><td><code>vector</code></td><td>G++ 5.4.0</td><td>501ms</td><td>1108ms</td><td>5103ms</td></tr><tr><td><code>vector</code></td><td>G++ 5.4.0 ( <code>-O2</code> )</td><td>365ms</td><td>794ms</td><td>3855ms</td></tr><tr><td>前向星</td><td>G++ 5.4.0</td><td>478ms</td><td>1025ms</td><td>5111ms</td></tr><tr><td>前向星</td><td>G++ 5.4.0 ( <code>-O2</code> )</td><td>477ms</td><td>1017ms</td><td>5109ms</td></tr></tbody></table><p>十分明显地，开了 <code>-O2</code> 优化的 <code>vector</code> 跑得飞快，而随着数据大小的上升，vector 的速度也越来越快。</p><p><code>bitset</code> 的大小是在编译时就被固定了，因此不会出现和 <code>vector</code> 一样浪费时间的情况。它的最大作用是节约空间。那里节约空间了？要知道，C++ 的任何类型都至少占用一个字节，包括 <code>bool</code> 。因此， <code>bool</code> 会浪费七个字节的空间。但其实 <code>bitset</code> 也是可以自己实现的。</p><div class="note warning"><p>编者注：<strong>原文内容存在争议，已删除。<strong>通常情况下，</strong> <code>int</code> 运算速度比 <code>long long</code> 快不少</strong>。</p></div><h4 id="部分连续容器"><a class="anchor" href="#部分连续容器">#</a> 部分连续容器</h4><p>如果你认为 <code>queue</code> （一种容器适配器）和 <code>deque</code> 应该在上一章出现，那你就错了。事实上，它们并不是完全连续容器。它们内部的实现有点诡谲。为什么这样说呢？因为它们在内存中是部分连续的，也就是说，当内存不够的时候，它们就会再申请一段，然后再连接过去，因此在内存中，它们是不完全连续的，是多个内存块组成的，每个块中存放的元素连续内存，而内存块又像链表一样连接起来。</p><p>因为有了这种方法，它们不需要每次申请空间时，都像 <code>vector</code> 一样复制原来的元素。而是可以在常数时间内完成这个操作。因为它们在内存中是不完全连续的，因此速度不会太低。也可以很好地避免循环队列大小估计错误的可能。</p><p>但要注意是否会出现对空队列取队首或出队的操作，而且由于每次都会申请一大段的连续空间，因此需要注意空间的开销。</p><p>当我做完测试后却大吃一惊。</p><table><thead><tr><th>实现方法</th><th>编译器</th><th>时间</th></tr></thead><tbody><tr><td>arr: <code>queue</code></td><td>G++ 5.4.0</td><td>25 ms</td></tr><tr><td>arr: <code>queue</code></td><td>G++ 5.4.0 ( <code>-O2</code> )</td><td>15 ms</td></tr><tr><td>stl: <code>queue</code></td><td>G++ 5.4.0</td><td>433 ms</td></tr><tr><td>stl: <code>queue</code></td><td>G++ 5.4.0 ( <code>-O2</code> )</td><td>31ms</td></tr><tr><td>arr: <code>deque</code></td><td>G++ 5.4.0</td><td>16 ms</td></tr><tr><td>arr: <code>deque</code></td><td>G++ 5.4.0 ( <code>-O2</code> )</td><td>4 ms</td></tr><tr><td>stl: <code>deque</code></td><td>G++ 5.4.0</td><td>850 ms</td></tr><tr><td>stl: <code>deque</code></td><td>G++ 5.4.0 ( <code>-O2</code> )</td><td>58 ms</td></tr></tbody></table><p>为什么会出现这种情况？</p><p>其实 <code>queue</code> 默认实现方法是封装 <code>deque</code> ，通过更改模板参数可以使用 <code>vector</code> 和 <code>list</code> 实现。而 <code>deque</code> 呢？由于其内存不完全连续，因此导致了过多的内存跳转，浪费了大量时间，由此可得，部分连续容器和完全连续容器的效率差极大。</p><p>因此，在能使用连续空间的情况下，尽可能地使用完全连续容器。</p><h4 id="节点容器"><a class="anchor" href="#节点容器">#</a> 节点容器</h4><p>节点容器就比较多了。常见的 <code>map</code> ， <code>set</code> 和 <code>list</code> 都属于它的范畴。</p><p>其中， <code>list</code> 有点像 <code>deque</code> ，和其原理差不多，只是内存块的大小恒为 1，插入和删除都可以在常数时间内完成。唯一的缺点是不支持二分查找和随机访问。而且由于 <code>list</code> 是不连续容器，因此它的查询会导致内存频繁地跳转，因此只有在经常需要增加或删除的时候才会考虑使用 <code>list</code> 。</p><p><code>set</code> 和 <code>map</code> 属于关联容器，关联容器支持高效的关键字查找和访问，内部是以一种叫做红黑树的 BST 实现的，但它太复杂了，它的插入有 5 种情况，删除有 6 种情况，是 “当今信息界中平均速度最快的 BST”，比我们在 OI 比赛中有能力在时间内手动实现的 BST 快得多。</p><p>因此， <code>set</code> 和 <code>map</code> 的查询时间和红黑树的时间复杂度一致，基本上所有操作都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\log size</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="mord mathnormal">e</span></span></span></span> 级别的，包括迭代器的 <code>++</code> 和 <code>—</code> 操作，它们在 BST 中相当于求前驱和后继。而且由于它们是节点容器，因此在内存中是断续的，反复地跳转可能导致更多的开销。</p><p>但当需要自己实现部分（不包括一些特别的功能，例如求排名）平衡树的功能时，用 <code>set</code> 和 <code>map</code> 一般会比手写更优。</p><p>如果遇到了不能用 <code>set</code> 和 <code>map</code> 的情况，并不推荐用 Splay，因为它的常数太大了，这里推荐一种极好的 BST: <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTU1MDk3L2FydGljbGUvZGV0YWlscy84MzM3ODE2Ng==">替罪羊树 (Scapegoat Tree)</span>，它的思想非常简单：当且仅当某棵子树的不平衡度超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.0037em">α</span></span></span></span> 时，暴力重构整棵子树，从而避免了旋转的操作。</p><hr><div class="note info"><p>本文转载自：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTU1MDk3L2FydGljbGUvZGV0YWlscy84MzA4MzA1MQ==">https://blog.csdn.net/qq_40155097/article/details/83083051</span></p><p>原作者：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTU1MDk3">Victor Miller</span></p><p>版权声明：本文为 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTU1MDk3">Victor Miller</span> 原创文章，遵循 <span class="exturl" data-url="aHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktc2EvNC4wLw==">CC 4.0 BY-SA</span> 版权协议，转载请附上原文出处链接和本声明。</p></div><p>推荐阅读：</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvZW5jb3JlL2lvLXlvdS1odWEtbmVpLXN1by1zaGk=">浅谈 C++ IO 优化 —— 读优输优方法集锦 - encore 的博客 - 洛谷博客</span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvemhhb2ppbnhpL29wdGltaXpl">浅谈底层常数优化及编译器优化 - zhaojinxi 的博客 - 洛谷博客</span></p><div class="tags"><a href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag"><i class="ic i-tag"></i> 技术</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2021-05-31 11:51:54" itemprop="dateModified" datetime="2021-05-31T11:51:54+08:00">2021-05-31</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="//cdn.jsdelivr.net/gh/Fidelxyz/fidelxyz.github.io@latest/images/wechatpay.webp" alt="玄云Fidel WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="//cdn.jsdelivr.net/gh/Fidelxyz/fidelxyz.github.io@latest/images/alipay.webp" alt="玄云Fidel Alipay"><p>Alipay</p></div><div><img data-src="//cdn.jsdelivr.net/gh/Fidelxyz/fidelxyz.github.io@latest/images/afdian.webp" alt="玄云Fidel afdian"><p>afdian</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>玄云Fidel <i class="ic i-at"><em>@</em></i>Fidel's Lab</li><li class="link"><strong>Post link: </strong><a href="https://fidel.js.org/2021/02/14/cpp-optimization/" title="【转载】还能这样玩 —— 关于一些 OI 的黑 (sao) 科 (cao) 技 (zuo) 优化">https://fidel.js.org/2021/02/14/cpp-optimization/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2020/11/15/2020-CSPS-NOIP/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicm0fdw5cj20zk0m8hdt.jpg" title="CSP-S 2020 游记 &amp; NOIP 2020 爆零记"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>CSP-S 2020 游记 & NOIP 2020 爆零记</h3></a></div><div class="item right"><a href="/2021/02/15/talk-about-something/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipevo9j1jj20zk0m8e81.jpg" title="随便聊聊"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>随便聊聊</h3></a></div></div><div class="wrap" id="comments"><div id="gitalk-container"></div></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%8D%E8%B4%A3%E5%A3%B0%E6%98%8E"><span class="toc-number">1.</span> <span class="toc-text">免责声明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gcc-%E7%B3%BB%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">GCC 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#o-%E7%B3%BB%E5%88%97"><span class="toc-number">2.1.</span> <span class="toc-text">O 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#-o1"><span class="toc-number">2.1.1.</span> <span class="toc-text">-O1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-o2"><span class="toc-number">2.1.2.</span> <span class="toc-text">-O2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-o3"><span class="toc-number">2.1.3.</span> <span class="toc-text">-O3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-os"><span class="toc-number">2.1.4.</span> <span class="toc-text">-Os</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E7%9B%AE%E6%A0%87%E6%9C%BA%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">针对目标机器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#-marchcpu-type"><span class="toc-number">2.2.1.</span> <span class="toc-text">-march&#x3D;cpu-type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-mfpmathunit"><span class="toc-number">2.2.2.</span> <span class="toc-text">-mfpmath&#x3D;unit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%8C%87%E5%AE%9A%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">2.2.3.</span> <span class="toc-text">加载指定指令集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%AF%94%E8%BE%83%E6%9C%89%E6%95%88%E7%9A%84%E9%80%89%E9%A1%B9"><span class="toc-number">2.3.</span> <span class="toc-text">其他比较有效的选项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#-ftracer"><span class="toc-number">2.3.1.</span> <span class="toc-text">-ftracer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-ffast-math"><span class="toc-number">2.3.2.</span> <span class="toc-text">-ffast-math</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-fivopts"><span class="toc-number">2.3.3.</span> <span class="toc-text">-fivopts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-ftree-parallelize-loopsn"><span class="toc-number">2.3.4.</span> <span class="toc-text">-ftree-parallelize-loops&#x3D;n</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-ftree-loop-linear"><span class="toc-number">2.3.5.</span> <span class="toc-text">-ftree-loop-linear</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-fforce-addr"><span class="toc-number">2.3.6.</span> <span class="toc-text">-fforce-addr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-floop-interchange"><span class="toc-number">2.3.7.</span> <span class="toc-text">-floop-interchange</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-fvisibilityhidden"><span class="toc-number">2.3.8.</span> <span class="toc-text">-fvisibility&#x3D;hidden</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-minline-all-stringops"><span class="toc-number">2.3.9.</span> <span class="toc-text">-minline-all-stringops</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-m64"><span class="toc-number">2.3.10.</span> <span class="toc-text">-m64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-fprefetch-loop-arrays"><span class="toc-number">2.3.11.</span> <span class="toc-text">-fprefetch-loop-arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-pipe"><span class="toc-number">2.3.12.</span> <span class="toc-text">-pipe</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E9%80%89%E9%A1%B9%E5%BC%80%E5%85%B3"><span class="toc-number">2.4.</span> <span class="toc-text">推荐选项开关</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96%E5%9D%91"><span class="toc-number">3.</span> <span class="toc-text">底层优化（坑）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#io-%E4%BC%98%E5%8C%96"><span class="toc-number">3.1.</span> <span class="toc-text">I&#x2F;O 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%85%A5%E4%BC%98%E5%8C%96"><span class="toc-number">3.1.1.</span> <span class="toc-text">读入优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96"><span class="toc-number">3.1.2.</span> <span class="toc-text">输出优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">3.2.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%E5%92%8C%E5%8F%B3%E7%A7%BB%E7%9A%84%E5%A4%A9%E4%B8%8A%E5%9C%B0%E4%B8%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">左移和右移的天上地下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mod-%E5%92%8C-and-%E7%9A%84%E6%88%98%E4%BA%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">Mod 和 And 的战争</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xor-%E5%92%8C-temp-%E7%9A%84%E6%95%85%E4%BA%8B"><span class="toc-number">3.2.3.</span> <span class="toc-text">Xor 和 temp 的故事</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A5%9E%E5%A5%87%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7"><span class="toc-number">3.2.4.</span> <span class="toc-text">神奇的 “位运算技巧”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xor-%E5%92%8C%E7%BD%91%E7%BB%9C%E6%B5%81%E7%9A%84%E6%95%85%E4%BA%8B"><span class="toc-number">3.2.5.</span> <span class="toc-text">Xor 和网络流的故事</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.3.</span> <span class="toc-text">条件语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if-%E5%92%8C-%E7%9A%84%E6%95%85%E4%BA%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">if 和 ?: 的故事</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-%E5%92%8C-if-else-%E7%9A%84%E6%95%85%E4%BA%8B"><span class="toc-number">3.3.2.</span> <span class="toc-text">switch 和 if-else 的故事</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E8%B7%AF%E7%9A%84%E6%95%85%E4%BA%8B"><span class="toc-number">3.3.3.</span> <span class="toc-text">短路的故事</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%95%85%E4%BA%8B"><span class="toc-number">3.3.4.</span> <span class="toc-text">布尔表达式和逗号运算符的故事</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#standard-template-library"><span class="toc-number">3.4.</span> <span class="toc-text">Standard Template Library</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">3.4.1.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%BF%9E%E7%BB%AD%E5%AE%B9%E5%99%A8"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">完全连续容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E8%BF%9E%E7%BB%AD%E5%AE%B9%E5%99%A8"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">部分连续容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%AE%B9%E5%99%A8"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">节点容器</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="玄云Fidel" data-src="//cdn.jsdelivr.net/gh/Fidelxyz/fidelxyz.github.io@latest/images/avatar.webp"><p class="name" itemprop="name">玄云Fidel</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">15</span> <span class="name">posts</span></a></div><div class="item tags"><a href="/tags/"><span class="count">4</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0ZpZGVseHl6" title="https:&#x2F;&#x2F;github.com&#x2F;Fidelxyz"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmZpZGVseHl6QGZveG1haWwuY29t" title="mailto:fidelxyz@foxmail.com"><i class="ic i-envelope"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMzY2NjQ0ODIw" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;366644820"><i class="ic i-bilibili"></i></span> <span class="exturl item youtube" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vY2hhbm5lbC9VQ2hRYnYxTGxhcFlIMGJBX21GS1dVdkE=" title="https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UChQbv1LlapYH0bA_mFKWUvA"><i class="ic i-youtube"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/2020/04/05/new-about/" rel="section"><i class="ic i-info-circle"></i>About</a></li><li class="item"><a href="/friends" rel="section"><i class="ic i-heart"></i>Friends</a></li><li class="item"><a href="/feed" rel="section"><i class="ic i-rss"></i>Feed</a></li><li class="item"><a href="/update-log" rel="section"><i class="ic i-file"></i>Update Log</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2020/11/15/2020-CSPS-NOIP/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/02/15/talk-about-something/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">玄云Fidel @ Fidel's Lab</span></div><div class="icp"><span><a href="https://icp.gov.moe" target="_blank">萌ICP备 </a><a href="https://icp.gov.moe/?keyword=2020020202" target="_blank">2020020202号</a></span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/02/14/cpp-optimization/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,gitalk:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://polyfill.alicdn.com/polyfill.min.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="//cdn.jsdelivr.net/gh/Fidelxyz/fidelxyz.github.io@latest/js/app.js"></script></body></html>